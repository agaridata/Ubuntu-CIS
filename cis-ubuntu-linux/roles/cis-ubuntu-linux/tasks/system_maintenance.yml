---

- name: "6.1.10 Ensure no world writable files exist (Scored)"
  shell: df --local -P | awk {'if (NR!=1) print $6'} | xargs -I '{}' find '{}' -xdev -type f -perm -0002 -print
  changed_when: false
  failed_when: false
  check_mode: no
  register: world_files
  tags:
    - scored
    - section_6

- debug:
    msg: "{{ item }}"
  with_items: "{{world_files.stdout_lines}}"
  tags:
    - scored
    - section_6

- name: "6.1.10 Ensure no world writable files exist (Scored)"
  command: chmod o-w {{ item }}
  with_items: "{{world_files.stdout_lines}}"
  tags:
    - scored
    - section_6

- name: "6.1.11 Ensure no unowned files or directories exist (Scored)"
  shell: df --local -P | awk {'if (NR!=1) print $6'} | xargs -I '{}' find '{}' -xdev -nouser -ls | awk '{print $11}'
  changed_when: false
  failed_when: false
  check_mode: no
  register: unowned_files
  tags:
    - scored
    - section_6

- debug:
    msg: "{{ item }}"
  with_items: "{{unowned_files.stdout_lines}}"
  tags:
    - scored
    - section_6

- name: "6.1.11 Ensure no unowned files or directories exist (Scored)"
  command: chown root:root {{ item }}
  with_items: "{{unowned_files.stdout_lines}}"
  tags:
    - scored
    - section_6

- name: "6.1.12 Ensure no ungrouped files or directories exist (Scored)"
  shell: df --local -P | awk {'if (NR!=1) print $6'} | xargs -I '{}' find '{}' -xdev -nogroup -ls | awk '{print $11}'
  changed_when: false
  failed_when: false
  check_mode: no
  register: ungrouped_files
  tags:
    - scored
    - section_6

- debug:
    msg: "{{ item }}"
  with_items: "{{ungrouped_files.stdout_lines}}"
  tags:
    - scored
    - section_6

- name: "6.1.12 Ensure no unowned files or directories exist (Scored)"
  command: chown :root {{ item }}
  with_items: "{{ungrouped_files.stdout_lines}}"
  tags:
    - scored
    - section_6

- name: "6.1.13 Audit SUID executables (Not Scored)"
  shell: df --local -P | awk {'if (NR!=1) print $6'} | xargs -I '{}' find '{}' -xdev -type f -perm -4000 -print
  changed_when: False
  failed_when: False
  check_mode: no
  register: suid_files
  tags:
    - not_scored
    - section_6

- debug:
    msg: "Audit SUID {{ item }}"
  with_items: "{{suid_files.stdout_lines}}"
  tags:
    - not_scored
    - section_6

- name: "6.1.14 Audit SGID executables (Not Scored)"
  shell: df --local -P | awk {'if (NR!=1) print $6'} | xargs -I '{}' find '{}' -xdev -type f -perm -2000 -print
  changed_when: False
  failed_when: False
  check_mode: no
  register: gsuid_files
  tags:
    - not_scored
    - section_6
  
- debug:
    msg: "Audit SGID {{ item }}"
  with_items: "{{gsuid_files.stdout_lines}}"
  tags:
    - not_scored
    - section_6


- name: "6.2.6 Ensure root PATH Integrity (Scored)"
  shell: |
    if [ "`echo $PATH | grep :: `" != "" ]; then
      echo "Empty Directory in PATH (::)"
    fi

    if [ "`echo $PATH | grep :$`" != "" ]; then
      echo "Trailing : in PATH"
    fi

    p=`echo $PATH | sed -e 's/::/:/' -e 's/:$//' -e 's/:/ /g'`
    set -- $p
    while [ "$1" != "" ]; do
      if [ "$1" = "." ]; then
        echo "PATH contains ."
        shift
        continue
      fi
      if [ -d $1 ]; then
        dirperm=`ls -ldH $1 | cut -f1 -d" "`
        if [ `echo $dirperm | cut -c6 ` != "-" ]; then
          echo "Group Write permission set on directory $1"
        fi
        if [ `echo $dirperm | cut -c9 ` != "-" ]; then
          echo "Other Write permission set on directory $1"
        fi
        dirown=`ls -ldH $1 | awk '{print $3}'`
        if [ "$dirown" != "root" ] ; then
          echo $1
        fi
      else
        echo $1
      fi
      shift
    done
  args:
    executable: /bin/bash
  register: root_path_integrity
  tags:
    - scored
    - section_6

- debug: 
    msg: "{{ item }} is not owned by root"
  with_items: "{{root_path_integrity.stdout_lines}}"
  tags:
    - scored
    - section_6

- name: "6.2.6 Ensure root PATH Integrity (Scored)"
  command: chown root:root {{ item }}
  with_items: "{{root_path_integrity.stdout_lines}}"
  tags:
    - scored
    - section_6

- name: "6.2.7 Ensure all users' home directories exist (Scored)"
  shell: |
    cat /etc/passwd | egrep -v '^(root|halt|sync|shutdown)' | awk -F: '($7 != "/usr/sbin/nologin" && $7 != "/bin/false") { print $1 " " $6 }' | while read user dir; do
      if [ ! -d "$dir" ]; then
        for i in $dir ; do mkdir -p $dir ; chown -R $user:$user $dir ; cp -R /etc/skel/. $dir ; done
        echo "Create a home directory $dir of user $user which does not exist"
      fi
    done
  args:
    executable: /bin/bash    
  register: home_directories_exist
  tags:
    - scored
    - section_6

- debug: 
    msg: "{{home_directories_exist.stdout_lines}}"
  tags:
    - scored
    - section_6

- name: "6.2.8 Ensure users' home directories permissions are 750 or more restrictive (Scored)"
  shell: find /home/* -maxdepth 0 -type d 
  register: user_dirs
  tags:
    - scored
    - section_6

- name: "6.2.8 Ensure users' home directories permissions are 750 or more restrictive (Scored)"
  file:
    path: "{{ item }}"
    mode: 0750
  with_items: "{{ user_dirs.stdout_lines }}"
  tags:
    - scored
    - section_6

- name: "6.2.9 Ensure users own their home directories (Scored)"
  shell: |
    cat /etc/passwd | egrep -v '^(root|halt|sync|shutdown)' | awk -F: '($7 != "/usr/sbin/nologin" && $7 != "/bin/false") { print $1 " " $6 }' | while read user dir; do
      if [ ! -d "$dir" ]; then
        echo "The home directory ($dir) of user $user does not exist."
      else
        owner=$(stat -L -c "%U" "$dir")
        if [ "$owner" != "$user" ]; then
          echo "The home directory ($dir) of user $user is owned by $owner. Fixing ..."
          for i in $dir ; do chown $user:$user $dir ; done
        fi
      fi
    done
  args:
    executable: /bin/bash   
  register: home_directories_own
  tags:
    - scored
    - section_6

- debug:
    msg: "{{home_directories_own.stdout_lines}}"
  tags:
    - scored
    - section_6

- name: "6.2.10 Ensure users' dot files are not group or world writable (Scored)"
  shell: |
    cat /etc/passwd | egrep -v '^(root|halt|sync|shutdown)' | awk -F: '($7 != "/usr/sbin/nologin" && $7 != "/bin/false") { print $1 " " $6 }' | while read user dir; do
      if [ ! -d "$dir" ]; then
        echo "The home directory ($dir) of user $user does not exist."
      else
        for file in $dir/.[A-Za-z0-9]*; do
          if [ ! -h "$file" -a -f "$file" ]; then
            fileperm=`ls -ld $file | cut -f1 -d" "`
            
            if [ `echo $fileperm | cut -c6`  != "-" ]; then
              echo "Group Write permission set on file $file"
            fi
            if [ `echo $fileperm | cut -c9`  != "-" ]; then
              echo "Other Write permission set on file $file"
            fi
          fi
        done
      fi
    done
  args:
    executable: /bin/bash 
  register: user_dot_files
  tags:
    - scored
    - section_6
  
- debug:
     msg: "{{user_dot_files.stdout_lines}}"
  tags:
    - scored
    - section_6

- name: "6.2.16 Ensure no duplicate UIDs exist (Scored)"
  shell: |
    cat /etc/passwd | cut -f3 -d":" | sort -n | uniq -c | while read x ; do
      [ -z "$x" ] && break
      set - $x
      if [ $1 -gt 1 ]; then
        users=`awk -F: '($3 == n) { print $1 }' n=$2 /etc/passwd | xargs`
        echo "Duplicate UID ($2): ${users}"
      fi
    done
  args:
    executable: /bin/bash 
  register: duplicate_uids
  tags:
    - scored
    - section_6

- debug: 
     msg: "{{duplicate_uids.stdout_lines}}"

- name: 6.2.17 Ensure no duplicate GIDs exist (Scored)
  shell: |
    cat /etc/group | cut -f3 -d":" | sort -n | uniq -c | while read x ; do
      [ -z "$x" ] && break
      set - $x
      if [ $1 -gt 1 ]; then
        groups=`awk -F: '($3 == n) { print $1 }' n=$2 /etc/group | xargs`
        echo "Duplicate GID ($2): ${groups}"
      fi
    done
  args:
    executable: /bin/bash 
  register: duplicate_gids
  tags:
    - scored
    - section_6

- debug: 
    msg: "{{duplicate_gids.stdout_lines}}"
  tags:
    - scored
    - section_6

- name: "6.2.18 Ensure no duplicate user names exist (Scored)"
  shell: |
    cat /etc/passwd | cut -f1 -d":" | sort -n | uniq -c | while read x ; do
      [ -z "$x" ] && break
      set - $x
      if [ $1 -gt 1 ]; then
        uids=`awk -F: '($1 == n) { print $3 }' n=$2 /etc/passwd | xargs`
        echo "Duplicate User Name ($2): ${uids}"
      fi
    done
  args:
    executable: /bin/bash 
  register: duplicate_users
  tags:
    - scored
    - section_6

- debug:
    msg: "{{duplicate_users.stdout_lines}}"
  tags:
    - scored
    - section_6

- name: "6.2.19 Ensure no duplicate group names exist (Scored)"
  shell: |
    cat /etc/group | cut -f1 -d":" | sort -n | uniq -c | while read x ; do
      [ -z "$x" ] && break
      set - $x
      if [ $1 -gt 1 ]; then
        gids=`gawk -F: '($1 == n) { print $3 }' n=$2 /etc/group | xargs`
        echo "Duplicate Group Name ($2): ${gids}"
      fi
    done
  args:
    executable: /bin/bash 
  register: duplicate_groups
  tags:
    - scored
    - section_6

- debug:
    msg: "{{duplicate_groups.stdout_lines}}"
  tags:
    - scored
    - section_6
